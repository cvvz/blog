---
title: "进程间通信"
date: 2018-11-02T22:34:20+08:00
draft: false
comments: true
keywords: ["IPC"]
tags: ["计算机基础"]
---

进程间通信的六种方式：

- 管道
- 共享内存
- 消息队列
- 信号量
- 信号
- socket

# 管道

管道机制和UNIX系统的文件系统密切关联，使用管道和使用文件系统非常类似。实际上使用**管道可以看成是创建了一个不会残留的临时文件，一个进程写文件，另一个进程读文件，从而实现了进程间通信**。

管道分为 **匿名管道** 和 **FIFO**。

## 匿名管道

使用 `pipe` 函数创建匿名管道。它返回两个文件描述符，`fd[0]`是管道的读端，`fd[1]`是写端。

如果进程只调用`pipe`，那么只能自写自读，基本没什么用。

因此，**使用`pipe`创建管道后，必然要使用 `fork` 创建子进程，这样就可以做到父子进程使用不同的fd进行读写通信**。

### popen

库函数 `popen` 就是使用匿名管道实现的。函数原型：

```C
FILE * popen（const char *cmdstring, const char *type）;
```

`popen`创建了一个管道，然后执行fork，在子进程中使用`exec`执行cmdstring；返回的文件指针根据参数type指向管道的读或写端。

type可取"w"和"r"：

- 取"w"时，返回的文件指针指向管道的写端fd[1]，子进程通过`dup2`将`stdin`复制到fd[0]，而cmdstring执行依赖`stdin`，就等于依赖父进程通过文件指针写入管道了；

- 取"r"时，文件指针指向管道的读端fd[0]，子进程通过`dup2`将`stdout`复制到fd[1]，而cmdstring执行默认输出到`stdout`，那么父进程就可以通过该文件指针读出cmdstring命令的输出。

通过 `pclose` 函数关闭打开的文件指针，并使用`waitpid`关闭子进程;因此`popen`后如果不执行`pclose`将造成内存泄漏和僵尸进程。

## FIFO

`FIFO`可以用来在不相关的进程间通信。

`FIFO`是一种文件类型，所以创建`FIFO`就是创建文件。通过 `mkfifo` 函数创建 `FIFO` 时，要指定一个具体的文件路径。

创建了`FIFO`之后，就可以通过标准文件操作（`open`、`read`、`write`、`close`）来使用它。毕竟在Linux中，一切皆文件。

# XSI IPC

**消息队列、信号量、共享内存被统称为`XSI IPC`**，他们之间有很多共通之处：

1. 独立于文件系统，有自己的一套操作管理函数和内核数据结构；不能像管理文件一样管理这些资源。
2. 这些资源归属于操作系统，而不属于某个进程，如果进程退出前忘记回收资源，资源不会自己释放掉，可能影响系统内其他进程。
3. 进程通过`xxxget`函数并指定参数key的方式获得一个id，通过id来使用和管理指定的资源；id是进程内管理资源的标识符，不具有全局性，key值才是全局标识符；两个进程指定同一个key值就能获取同一个资源，从而关联起来。

## 信号量

信号量(semaphore)作为IPC的角色是专门用来控制多个进程访问共享资源的，实际就是一个计数器。

通过`semget`、`semctl`、`semop`管理信号量。

## 共享内存和mmap

### mmap

`mmap`把磁盘上某个具体文件映射到进程的内存映射区中，以实现对文件更快的读写。

通过将同一文件映射到不同的进程中内存空间，就可以实现进程间共享内存通信。

### 共享内存

共享内存可以看成是把内核中的一块内存映射到进程的内存映射区。这样，两个进程共享同一块内存就可以实现通信了，由于是直接对内存读写，这种IPC方式也是最快的。

通过`shmget`、`shmctl`、`shmat`、`shmdt`管理共享内存。
