---
title: "重学数据结构和算法"
date: 2021-07-18T21:14:55+08:00
draft: false
comments: true
toc: true
autoCollapseToc: false
keywords: ["code", "golang"]
tags: ["code", "golang"]
---

## 常见数据结构

### 数组

C数组访问越界会造成“踩内存”。

很多高级语言都基于基础的数组提供了“容器类”，比如 Java 中的 ArrayList、C++ STL 中的 vector、golang中的slice，“容器类”的优势在于可以动态扩容、插入和删除元素时自动搬移数据，用起来心智负担很低，**在实现算法时更加handy**。

### 链表

### 单链表、双链表、循环链表

技巧：**使用哨兵节点（带头链表）**。这样在插入第一个节点和删除最后一个节点时，就不需要做特殊判断，可以简化实现逻辑

> 所有高级数据结构都是在数组和链表的基础上衍生出来的。

### 栈和队列

“操作受限”的线性表，只支持两种基本操作：push, pop。

递归的算法都可以用栈来实现。

> 高性能定时器，除了可以用堆实现（**比如golang的timer就是用最小四叉堆**），还可以用**环形队列**，详见 [时间轮算法 HashedWheelTimer](https://zhuanlan.zhihu.com/p/65835110)

### hash表

> 高级语言内置了hash表，比如Java 中的 HashMap，golang中的map数据类型。

1. hash表来源于**数组**，借助**散列函数**对数组这种数据结构进行扩展，也就是将key映射为数组下标index。

2. 将key转化为数组下标的方法称为**散列函数**，散列函数的计算结果称为**hash值**。数据存储在**hash值**对应的**数组下标**位置。

> 实现hash表所使用的hash算法要求执行**速度快**，值是否能**平均分布**在各个槽中（比如简单的取模算法）。并不是很在乎**安全性**（是否能反向解密出原始数据）和**hash冲突**（哈希值相同）。所以不会使用**加密用**的哈希算法。
>
> hash函数,有加密型和非加密型。加密型的一般用于加密数据、数字摘要等，典型代表就是md5、sha1、sha256、aes256 。非加密型的一般就是查找。

### hash算法

**hash算法在hash表中的应用就是散列函数。**

[在分布式系统中的应用](https://time.geekbang.org/column/article/67388)：

1. 负载均衡
2. 数据分片
3. 分布式存储（**一致性哈希**）

> 取模似乎是用的最多的一种哈希算法。MD5、SHA256等哈希算法，一般会用在把一个大的二进制文件转换为一个唯一的二进制数值。

### 树

#### 二叉树

* 二叉树的遍历：**前中后指的是当前节点和左右子树谁先打印**
* 完全二叉树和满二叉树：可以用**数组存储**
* 二叉查找树：**和有序数组的二分查找类比记忆**
* 平衡二叉查找树：二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 log2n 的情况，从而导致各个操作的效率下降。**极端情况下，二叉树会退化为链表**，时间复杂度会退化到 O(n)。所以又发明了**平衡二叉查找树**。
    > “平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。
* 红黑树

#### [堆](https://leetcode-cn.com/tag/heap-priority-queue/problemset/)

**堆的核心操作：**

0. 核心中的核心：堆化（heapify）
   1. **从上往下**
   2. **从下往上**
1. 交换堆顶和堆尾，并进行从上往下堆化
2. 插入堆尾，并进行从下往上堆化
3. 建堆
   1. 从上往下堆化
   2. 从下往上堆化

[**堆的应用**](https://time.geekbang.org/column/article/70187):

1. 优先级队列
   1. 合并有序小文件
   2. 定时器
2. [数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)、99线问题
3. TopK问题
   1. [静态topK](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)（从上往下堆化）
   2. [动态topK](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)（从下往上堆化）

### 图

**度（degree）**：in-degree、out-degree

**数据结构（存储方法）**：

* 邻接矩阵
* 邻接表

> **面试的时候更多的是把二叉树和图结合起来考察，所以会用二叉树（链表）来表示图**

**图的搜索算法**：BFS、DFS

## 常见算法

### 排序

**冒泡排序、插入排序、选择排序**：三种O(n2)的简单算法。

**归并排序**和**快速排序**：**分治**。我们可以借鉴快排的思想，来解决非排序的问题，比如[静态topK](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)问题。

**堆排序**：步骤分为

1. 建堆：堆化
   1. 方法一：**从第一个非叶子结点开始**，依次执行从上往下堆化
   2. 方法二：不断插入尾部，并对新插入节点执行从下往上堆化
2. 调整：不断交换堆顶和堆尾元素 + 重新堆化

> **注意，在做堆排序时，由于调整这一步是从上往下堆化，所以建堆时最好用方法一，这样heapify函数才能复用。**

### 搜索

> 算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的

#### 广度优先搜索

通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助**队列**来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径。

#### 深度优先搜索

用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助**栈**来实现的。

### 二分查找

二分查找的**三个容易出错的地方**：

* 循环退出条件
* mid 的取值可能越界
* low 和 high 的更新。

二分查找可以用递归实现。

## 基本算法思想

### [贪心](https://leetcode-cn.com/tag/greedy/problemset/)

> 严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。

### [分治](https://leetcode-cn.com/tag/divide-and-conquer/problemset/)

> 分治经常用在海量数据处理的场景下，内存无法直接装载全部数据，就将数据分批装载进内存处理，再将结果进行合并。（给1TB的订单排序）
>
> 要判断清楚数据规模是不是可以直接装载进内存，比如：10亿个整数 = 80亿Byte( int=64bit ) ≈（不足）8GB，这个时候要考虑单机的实际可用内存大小是否可以直接装载8GB。

### [动态规划](https://leetcode-cn.com/tag/dynamic-programming/problemset/)

> DP的主要学习难点跟递归类似，那就是，求解问题的过程不太符合人类常规的思维方式。

### [回溯](https://leetcode-cn.com/tag/backtracking/problemset/)

> DFS利用的就是回溯算法思想。
